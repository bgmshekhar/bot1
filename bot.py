import os
import logging
import asyncio
from dotenv import load_dotenv
import telegram
from telegram import Update
from telegram.ext import Application, CommandHandler, MessageHandler, filters, CallbackContext, ContextTypes, PollHandler, JobQueue
import google.generativeai as genai

# Enable logging
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)
logger = logging.getLogger(__name__)

# Load environment variables
load_dotenv()
TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")  # Use the variable name from .env
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY") #also use the same variable name.

print(f"TELEGRAM_BOT_TOKEN: {TELEGRAM_BOT_TOKEN}")  # For debugging only (remove later!)
print(f"GEMINI_API_KEY: {GEMINI_API_KEY}") #Also print Gemini Key for debugging.

# Initialize Gemini
genai.configure(api_key=GEMINI_API_KEY)
model = genai.GenerativeModel('gemini-2.0-flash') # Use the Flash model

# --- Utility Functions ---

def escape_markdown(text: str) -> str:
    """Escapes special characters for Telegram MarkdownV2."""
    escape_chars = r"_*[]()~`>#+-=|{}.!"
    return "".join(["\\" + char if char in escape_chars else char for char in text])

# --- Global Variables ---
correct_answers = {}  # Dictionary to store correct answers and associated data
AUTHORIZED_USER_IDS = set()  # Use a set for efficient lookup
ACCESS_CODE = "085213" # Replace with your actual access code
POLL_DURATION = 15  # Poll duration in seconds (15 for testing)
channel_chat_id = int(os.getenv("CHANNEL_CHAT_ID", 1002374021898)) #Do not replace

# --- Command Handlers ---

async def start(update, context):
    if update.effective_user.id not in AUTHORIZED_USER_IDS:
        await update.message.reply_text("You are not authorized to use this bot. Please use /auth <access_code> to authorize.")
        return

    welcome_message = escape_markdown("""
Hello! I am a powerful bot powered by Gemini 2.0 Flash.

I can help you with:
- Searching the web using Gemini's knowledge (/search <query>)
- Creating single polls (/poll <question> <option1> <option2> ...)
- Creating multiple polls from a list of questions (send me a list of questions (one per line). I'll also tell you if the poll was answered correctly!

Type /help for a list of commands.

*Disclaimer:*  Responses are generated by AI and may not always be accurate.
    """)
    await update.message.reply_text(welcome_message, parse_mode=telegram.constants.ParseMode.MARKDOWN_V2)


async def search(update, context):
    if update.effective_user.id not in AUTHORIZED_USER_IDS:
        await update.message.reply_text("You are not authorized to use this bot. Please use /auth <access_code> to authorize.")
        return

    query = " ".join(context.args)
    if not query:
        await update.message.reply_text("Please provide a search query. Example: `/search What is the capital of France?`")
        return

    try:
        prompt = f"""Summarize information about the following topic:\n{query}\n\nProvide a concise and informative answer, no more than 200 words.
        Include relevant information, and try to use markdown formatting where appropriate.
        """

        response = model.generate_content(prompt)
        formatted_response = escape_markdown(response.text)

        await update.message.reply_text(formatted_response, parse_mode=telegram.constants.ParseMode.MARKDOWN_V2)

    except Exception as e:
        logger.error(f"Error during search: {e}")
        await update.message.reply_text("Sorry, I encountered an error while processing your search request.")


async def poll(update, context):
    if update.effective_user.id not in AUTHORIZED_USER_IDS:
        await update.message.reply_text("You are not authorized to use this bot. Please use /auth <access_code> to authorize.")
        return

    if len(context.args) < 3:
        await update.message.reply_text("Please provide a question and at least two options. Example: `/poll What is your favorite color? Red Blue Green`")
        return

    question = context.args[0]
    options = context.args[1:]

    try:
        await context.bot.send_poll(
            update.effective_chat.id,
            question,
            options,
            is_anonymous=False
        )
    except Exception as e:
        logger.error(f"Error creating poll: {e}")
        await update.message.reply_text("Sorry, I encountered an error while creating the poll.")

# --- Auth handler
async def authorize(update, context):
    if len(context.args) != 1:
        await update.message.reply_text("Please provide the access code. Example: `/auth mysecretcode`")
        return

    access_code = context.args[0]
    if access_code == ACCESS_CODE:
        AUTHORIZED_USER_IDS.add(update.effective_user.id)
        await update.message.reply_text("You have been authorized to use this bot.")
    else:
        await update.message.reply_text("Invalid access code.")

# --- NEW FUNCTION ---

async def send_poll_to_channel(context: CallbackContext, channel_chat_id: int, question: str, options: list, correct_answer: str):
    """Sends a poll to the specified channel."""
    try:
        message = await context.bot.send_poll(
            chat_id=channel_chat_id,
            question=question,
            options=options,
            is_anonymous=True,  # Changed to True
        )

        poll_id = message.poll.id
        correct_answers[poll_id] = {"correct_answer": correct_answer, "message_id": message.message_id, "chat_id":channel_chat_id}  # Store the correct answer + message_id + chat_id

        context.job_queue.run_once( #Use new function run_once
            callback=close_poll,
            when=POLL_DURATION, #Run the function after 15 seconds, it can be changed via global variable.
            chat_id = channel_chat_id,
            data= {"message_id":message.message_id, "poll_id":poll_id} #is a dictionary
        )


    except Exception as e:
        logger.error(f"Error sending poll to channel: {e}")

# --- NEW FUNCTION ----

async def delete_and_replace_poll(context: CallbackContext, channel_chat_id: int, poll_id: str, question: str, options: list, correct_answer: str):
    try:
        # Fetch the message_id associated with the poll_id in correct_answers
        message_id = None
        if poll_id in correct_answers:
             message_id = correct_answers[poll_id]["message_id"]


        print(f"Message ID to delete: {message_id}") #debug
        if message_id:
            await context.bot.delete_message(chat_id=channel_chat_id, message_id=message_id)
            print("Message deleted successfully.") #debug
        else:
            logger.warning(f"Message ID not found for poll_id: {poll_id}")

        # Re-send the information as a new message
        options_text = "\n".join([f"{i+1}. {opt}" for i, opt in enumerate(options)])
        #correct_index = options.index(correct_answer) + 1
        new_message_text = f"Poll: {question}\n{options_text}\n\nCorrect Answer: {correct_answer}" #modified
        await context.bot.send_message(chat_id=channel_chat_id, text=new_message_text, parse_mode=telegram.constants.ParseMode.MARKDOWN_V2)

    except Exception as e:
        logger.error(f"Error in delete_and_replace_poll: {e}")

# --- Message Handler ---

RATE_LIMIT_WINDOW = 60  # seconds
MAX_POLLS_PER_WINDOW = 3
user_poll_counts = {}  # Store poll counts per user
cleaned_options = []

async def handle_multiple_questions(update, context):
    global cleaned_options #Added

    if update.effective_user.id not in AUTHORIZED_USER_IDS:
        await update.message.reply_text("You are not authorized to use this bot. Please use /auth <access_code> to authorize.")
        return

    user_id = update.effective_user.id
    now = asyncio.get_event_loop().time()  # Monotonic time for rate limiting

    # Rate limiting logic
    if user_id in user_poll_counts and now - user_poll_counts[user_id][0] < RATE_LIMIT_WINDOW:
        if user_poll_counts[user_id][1] >= MAX_POLLS_PER_WINDOW:
            await update.message.reply_text("Please wait before creating more polls.  You've reached the rate limit.")
            return
        else:
            user_poll_counts[user_id][1] += 1  # Increment count
    else:
        user_poll_counts[user_id] = [now, 1]  # Reset count

    questions = update.message.text.splitlines()
    if len(questions) > 5:
        await update.message.reply_text("Sorry, I can only create a maximum of 5 polls at once.")
        return

    for question in questions:
        question = question.strip()
        if not question:
            continue

        try:
            prompt = f"""You are an expert in generating poll options. Given a question, provide 3-4 concise and relevant answer options. One of these options should be the correct answer. Mark the correct option with the tag <correct>. The options should be suitable for a general audience. Return the options as a comma-separated list, with *only* the options themselves (including the <correct> tag), and *nothing* else. Do not include any introductory phrases or explanations.
Question: {question}"""

            response = model.generate_content(prompt)
            options_text = response.text.strip()
            print(f"Gemini's Raw Output: {options_text}")  # Add this line for debugging

            if not options_text:
                logger.warning(f"Gemini failed to generate options for: {question}")
                # await update.message.reply_text(f"Could not generate options for the question: {question}. Skipping.") REMOVED!
                continue

            options = [opt.strip() for opt in options_text.split(',') if opt.strip()]
            correct_option = None  # Initialize correct_option
            cleaned_options = []

            for option in options:
                if "<correct>" in option:
                    correct_option = option.replace("<correct>", "").strip()
                    cleaned_options.append(option.replace("<correct>", "").strip()) # Strip after removal
                else:
                    cleaned_options.append(option.strip()) # Keep the original option

            print(f"Extracted Correct Option: {correct_option}")  # Add this line for debugging

            if len(cleaned_options) < 2:
                logger.warning(f"Gemini generated too few options ({len(cleaned_options)}) for: {question}")
                # await update.message.reply_text(f"Could not generate enough options for the question: {question}. Skipping.") REMOVED!
                continue

            if correct_option is None:
                logger.warning(f"Gemini did not mark a correct option for the question: {question}")
                # await update.message.reply_text(f"Gemini did not provide a correct answer for the question: {question}. Skipping.") REMOVED!
                continue
            await send_poll_to_channel(context, channel_chat_id, question, cleaned_options, correct_option)

        except Exception as e:
            logger.error(f"Error creating multiple polls: {e}")
            # await update.message.reply_text(f"Sorry, I encountered an error while creating a poll for the question: {question}") REMOVED!
            break

    # Clean up user rate limit if all polls are processed
    if user_id in user_poll_counts and user_poll_counts[user_id][1] == 1:
        del user_poll_counts[user_id]

async def close_poll(context: ContextTypes.DEFAULT_TYPE): #Define new funtion
    job = context.job
    try:
        message_id = job.data["message_id"]
        poll_id = job.data["poll_id"]
        await context.bot.stop_poll(chat_id=channel_chat_id, message_id=message_id)  # stop poll, keep everything, the chat id must be the one from channel

        if poll_id:
            correct_answer = correct_answers[poll_id]["correct_answer"]
            await context.bot.send_message(
                chat_id=channel_chat_id,
                text=f"The poll is now closed. The correct answer was: {escape_markdown(correct_answer)}",
                parse_mode=telegram.constants.ParseMode.MARKDOWN_V2
            )
        #del correct_answers[poll_id] #Remove
    except Exception as e:
        logger.error(f"Error stopping poll: {e}")

# --- Poll Results Handler ---
async def poll_results(update: Update, context: CallbackContext):
    """This handler will be triggered when a poll is closed."""
    print("poll_results handler has been triggered!")  # Add this line
    poll = update.poll
    poll_id = poll.id

    if update.effective_user is None or update.effective_user.id not in AUTHORIZED_USER_IDS:
        return

    if poll_id not in correct_answers:
        logger.warning(f"Received poll update for unknown poll id: {poll_id}")
        return  # Ignore if we don't know the answerr
    if poll_id in correct_answers: #add
      correct_answer = correct_answers[poll_id]["correct_answer"] #add
      del correct_answers[poll_id] #Remove

      await delete_and_replace_poll(context, channel_chat_id, poll.id, poll.question, cleaned_options, correct_answer)
      #del correct_answers[poll.id]

# --- Error Handler ---
async def error_handler(update: object, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Log the error."""
    logger.error(msg="Exception while handling an update:", exc_info=context.error)
    # You can add more sophisticated logging here, but for now, just log the error.

if __name__ == '__main__':
    # Set DEVELOPER_CHAT_ID - very important, or you won't receive error notifications!  Replace with your Telegram User ID.
    DEVELOPER_CHAT_ID = int(os.getenv("DEVELOPER_CHAT_ID", 1))  # Replace 0 with your actual user ID.  Set in .env.

    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("search", search))
    application.add_handler(CommandHandler("poll", poll))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_multiple_questions))
    # Add the new authorize handler
    application.add_handler(CommandHandler("auth", authorize))
    # Add poll result handler
    application.add_handler(PollHandler(poll_results))

    # Add error handler
    application.add_error_handler(error_handler)

    application.run_polling()
